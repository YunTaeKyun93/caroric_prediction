# Calorie Burn Prediction Project

운동 데이터를 기반으로 개인의 칼로리 소모량을 예측하는 회귀(Regression) 프로젝트입니다.  
본 프로젝트는 **점수 자체보다 재현 가능하고 일반화 가능한 실험 구조 설계**를 목표로 합니다.

---

## 1. 프로젝트 개요

이 프로젝트는 운동 시간, 심박수, 체중, 성별 등 개인별 운동 기록을 활용해  
한 번의 운동에서 실제로 소모된 **칼로리(정수형 타깃)**를 예측하는 회귀 문제입니다.

### 주요 특징

- 타깃 값: 정수형 칼로리
- 예측 방식: 연속값 회귀
- 평가 지표: RMSE
- 데이터 특성: 비선형 관계가 강한 운동·생체 데이터

본 프로젝트의 핵심 목표는 다음 두 가지입니다.

1. 새로운 데이터에도 잘 동작하는 **일반화 가능한 구조 설계**
2. 실험 결과를 언제든지 다시 검증할 수 있는 **재현 가능한 환경 구축**

---

## 2. 문제 정의 및 평가 전략

- 타깃은 정수형이지만, RMSE는 연속 오차 기준으로 계산됩니다.
- 따라서 예측값을 정수로 강제 변환하지 않고,  
  **연속 예측의 안정성을 우선 확보**하는 전략을 채택했습니다.
- 단일 모델 최고 점수보다는 **구조적으로 안정적인 성능 유지**를 중요하게 판단했습니다.

---

## 3. 실험 원칙 – 점수보다 구조

본 프로젝트는 점수 최적화보다 아래 원칙을 우선했습니다.

- **재현성**: 같은 실험은 항상 같은 결과가 나와야 한다
- **일반화**: 특정 split에만 잘 맞는 모델을 지양한다
- **확장성**: 모델 교체·추가가 구조 변경 없이 가능해야 한다

이를 위해 모든 실험은

- 고정된 데이터 분할
- K-Fold + OOF 기반 검증
- 파이프라인 구조
  를 기반으로 수행했습니다.

---

## 4. 프로젝트 폴더 구조

```text
project_root/
├── data/
│   ├── raw/                # 원본 데이터 (절대 수정 금지)
│   └── processed/          # 전처리 완료 데이터
│
├── src/
│   ├── features/           # Feature Engineering 로직
│   ├── preprocessing/      # 스케일링, 인코딩, 파이프라인
│   ├── modeling/            # XGB / LGBM / CatBoost 모델 정의
│   └── validation/          # K-Fold, OOF 생성 로직
│
├── run_script/
│   ├── train_base.py        # 단일 모델 실험
│   ├── train_stacking.py   # Stacking 실험
│   └── tune_optuna.py      # Optuna 튜닝
│
├── outputs/
│   ├── submissions/        # 제출 파일
│   └── oof_predictions/    # OOF 예측값
│
├── models/
│   └── best_params.json    # 최적 하이퍼파라미터
│
└── README.md
```

각 단계는 독립적으로 실행 가능하며,
특정 단계 수정 시 다른 단계에 영향을 최소화하도록 설계되었습니다.

## 6. Feature Engineering 전략

Feature Engineering은 “많이 생성”보다 “명확하게 관리”하는 전략을 사용했습니다.

기본 피처: 시간 기반 변수, 운동 강도

상호작용 피처: 의미가 명확한 조합만 사용

도메인 피처: 통계적 유의성 검증 후 유지

모든 피처 로직은 독립된 함수 단위로 분리하여

재사용성

디버깅 용이성

피처 중요도 추적
을 가능하게 했습니다.

## 7. 모델 전략

Base Models

XGBoost: 안정적인 수렴, 정규화 강점

LightGBM: 빠른 학습, 다른 오차 패턴 생성

CatBoost: 비선형 관계 학습에 강점 (단일 모델 최고 성능)

각 모델을 경쟁시키기보다 역할 분리 관점에서 사용했습니다.

## 8. Stacking 전략

최종 모델은 OOF 기반 Stacking 구조입니다.

각 베이스 모델의 OOF 예측값만 사용

Train 데이터 누수 완전 차단

메타 모델: Ridge Regression

극단값 완화

가중치 기반 안정화

Stacking의 성능은 모델의 강함이 아니라
서로 다른 오차를 구조적으로 결합한 결과입니다.

## 9. Optuna 튜닝의 역할과 한계

Optuna는 하이퍼파라미터 탐색 자동화 도구로 사용했습니다.

하지만 다음과 같은 문제는 해결할 수 없습니다.

잘못된 피처 설계

데이터 누수

검증 구조 오류

따라서 본 프로젝트에서는
구조 설계 → 검증 체계 → 튜닝
순서를 엄격히 유지했습니다.

## 10. 실패한 시도와 교훈

실패 사례

타깃 로그 변환 → RMSE와 불일치로 성능 하락

과도한 피처 생성 → 분산 증가, CV 불안정

반올림 후처리 → 연속성 파괴, Bias 증가

교훈

실험은 많이 하는 것보다
왜 실패했는지를 설명할 수 있어야 의미가 있다

## 11. 최종 정리

이 프로젝트의 진정한 성과는 RMSE 점수가 아니라,

재현 가능한 실험 구조

검증 가능한 모델 비교

확장 가능한 파이프라인

을 구축했다는 점입니다.

점수보다 구조가
지속 가능한 성능을 만든다는 것을 확인한 프로젝트였습니다.

#### =========================================================INIT README 삭제예정=========================================================

1️⃣ data/ — 데이터 관리 영역

목적: 데이터 누수 방지 + 실험 재현성 확보

📂 data/raw/

역할: 원본 데이터 저장

원칙: ❗절대 수정 금지

이유:

모든 실험이 동일한 출발점에서 시작되도록 보장

전처리 실수, 데이터 누수 원천 차단

팀원 주의사항:

여기 있는 파일은 읽기 전용이라고 생각하면 됨

📂 data/processed/

역할: 전처리 완료된 데이터 저장

내용:

스케일링, 인코딩 등 데이터 형태만 변환된 결과

이유:

“어디까지 처리된 데이터인지”를 명확히 구분

수정 포인트:

전처리 방식 변경 시 이 폴더의 데이터가 갱신됨

2️⃣ src/ — 핵심 로직 영역

목적: 단일 책임 원칙(SRP) 기반 구조

📂 src/features/

역할: Feature Engineering 전담

내용:

기본 피처 생성

상호작용 피처 생성

도메인 지식 기반 피처

설계 의도:

“피처를 바꾸고 싶으면 이 폴더만 보면 되게”

팀원 수정 포인트:

새로운 피처 추가/제거는 여기서만 수행

중요 원칙:

모델, 스케일링 로직 ❌

오직 “피처 생성”만 담당

📂 src/preprocessing/

역할: 데이터 전처리 로직

내용:

스케일링

인코딩

Pipeline 구성 요소

이유:

Feature Engineering과 전처리를 분리해 책임 명확화

수정 포인트:

스케일러 변경, 인코딩 방식 변경 시 여기만 수정

📂 src/modeling/

역할: 모델 정의

내용:

XGBoost

LightGBM

CatBoost

설계 의도:

모델을 교체해도 다른 코드에 영향 없게

팀원 이해 포인트:

“모델 하나 = 하나의 파일/클래스”

수정 포인트:

하이퍼파라미터 기본값

모델 구조 변경

📂 src/validation/

역할: 검증 전략 담당

내용:

K-Fold 설정

OOF 예측값 생성

중요 포인트:

모든 실험은 동일한 검증 로직 사용

이유:

점수 비교의 공정성 확보

팀원 주의사항:

검증 방식 변경 시 모든 결과가 바뀜 → 신중

3️⃣ run_script/ — 실험 실행 스크립트

목적: “실험 단위”를 명확히 분리

📄 train_base.py

역할: 단일 모델 실험 실행

사용 시점:

베이스라인 성능 확인

모델 단독 성능 비교

출력:

CV 점수

OOF 예측값

팀원 활용 예시:

“CatBoost만 돌려보고 싶다” → 이 파일 실행

📄 train_stacking.py

역할: Stacking 실험 실행

내용:

각 베이스 모델 OOF 로딩

Ridge 메타 모델 학습

핵심 포인트:

Train 데이터 누수 완전 차단

팀원 이해 포인트:

실제 테스트 환경과 동일한 예측 구조

📄 tune_optuna.py

역할: Optuna 기반 하이퍼파라미터 튜닝

설계 철학:

구조가 완성된 후에만 사용

주의사항:

이 파일이 성능을 “마법처럼” 올려주지는 않음

팀원 메시지:

“튜닝은 구조 위에서만 의미가 있다”

4️⃣ outputs/ — 결과 관리 영역

목적: 실험 결과를 자산으로 관리

📂 outputs/submissions/

역할: 최종 제출 파일 저장

이유:

어떤 제출이 어떤 실험에서 나왔는지 추적 가능

📂 outputs/oof_predictions/

역할: OOF 예측값 저장

중요성:

Stacking의 핵심 입력

실험 비교 기준 데이터

팀원 팁:

점수 비교할 때 여기부터 확인

5️⃣ models/ — 모델 메타정보
📄 best_params.json

역할: Optuna로 찾은 최적 파라미터 저장

이유:

실험 재현성 확보

튜닝 결과를 코드와 분리

팀원 활용:

동일 설정으로 재실험 가능

✅ 팀원들에게 꼭 전달해야 할 핵심 메시지 (요약)

이 프로젝트는 점수 중심이 아니라 구조 중심

파일 하나당 역할이 하나

모델을 바꿔도 파이프라인은 그대로

실험 결과는 항상 재현 가능

원하면 다음도 바로 만들어줄 수 있어:

📘 팀 위키용 README 버전

🎤 신입/비개발자용 쉬운 설명

❓ 팀원 질문 예상 Q&A

다음으로 뭘 원해?
